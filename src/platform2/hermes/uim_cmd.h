// Copyright 2018 The ChromiumOS Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// NOTE: THIS FILE IS AUTOMATICALLY GENERATED - DO NOT MODIFY

#ifndef HERMES_UIM_CMD_H_
#define HERMES_UIM_CMD_H_

#include <cstdint>

#include <base/check.h>
#include <base/logging.h>
#include <libqrtr.h>

#include "hermes/qmi_cmd_interface.h"

class UimCmd : public QmiCmdInterface {
 public:
  enum QmiType : uint16_t {
    kReset = 0x00,
    kSendApdu = 0x3B,
    kOpenLogicalChannel = 0x42,
    kSwitchSlot = 0x46,
    kGetSlots = 0x47,
  };

  explicit UimCmd(QmiType qmi_type)
      : service_(Service::kUim), qmi_type_(qmi_type) {}

  uint16_t qmi_type() const override {
    return static_cast<uint16_t>(qmi_type_);
  }

  Service service() const override { return service_; }

  const char* ToString() {
    switch (qmi_type_) {
      case QmiType::kReset:
        return "Reset";
      case QmiType::kSendApdu:
        return "SendApdu";
      case QmiType::kOpenLogicalChannel:
        return "OpenLogicalChannel";
      case QmiType::kSwitchSlot:
        return "SwitchSlot";
      case QmiType::kGetSlots:
        return "GetSlots";
      default:
        CHECK(false) << "Unrecognized value: "
                     << static_cast<uint16_t>(qmi_type_);
        return "";
    }
  }

 private:
  Service service_;
  QmiType qmi_type_;
};

constexpr int kIccidMaxSize = 20;

struct uim_qmi_result {
  uint16_t result;
  uint16_t error;
};

struct uim_card_result_t {
  uint8_t sw1;
  uint8_t sw2;
};

struct uim_open_logical_channel_req {
  uint8_t slot;
  bool aid_valid;
  uint8_t aid_len;
  uint8_t aid[kBufferDataSize];
};

struct uim_open_logical_channel_resp {
  uim_qmi_result result;
  bool channel_id_valid;
  uint8_t channel_id;
  bool card_result_valid;
  uim_card_result_t card_result;
  bool select_response_valid;
  uint8_t select_response_len;
  uint8_t select_response[kBufferDataSize];
};

struct uim_reset_req {};

struct uim_reset_resp {
  uim_qmi_result result;
};

struct uim_send_apdu_req {
  uint8_t slot;
  uint16_t apdu_len;
  uint8_t apdu[kBufferDataSize];
  bool channel_id_valid;
  uint8_t channel_id;
  bool procedure_bytes_valid;
  uint8_t procedure_bytes;
};

struct uim_send_apdu_resp {
  uim_qmi_result result;
  bool apdu_response_valid;
  uint16_t apdu_response_len;
  uint8_t apdu_response[kBufferDataSize];
};

struct uim_physical_slot_status {
  enum physical_card_status_t : uint32_t {
    kCardUnknown = 0,
    kCardAbsent = 1,
    kCardPresent = 2,
  } physical_card_status;
  enum physical_slot_state_t : uint32_t {
    kSlotInactive = 0,
    kSlotActive = 1,
  } physical_slot_state;
  uint8_t logical_slot;
  uint8_t iccid_len;
  uint8_t iccid[kIccidMaxSize];
};

struct uim_slot_eid_info {
  uint8_t eid_len;
  uint8_t eid[255];
};

struct uim_physical_slot_info {
  uint32_t card_protocol;
  uint8_t num_app;
  uint8_t atr_len;
  uint8_t atr[255];
  uint8_t is_euicc;
};

struct uim_get_slots_req {};

struct uim_get_slots_resp {
  uim_qmi_result result;
  bool status_valid;
  uint8_t status_len;
  uim_physical_slot_status status[10];
  bool slot_info_valid;
  uint8_t slot_info_len;
  uim_physical_slot_info slot_info[10];
  bool eid_info_valid;
  uint8_t eid_info_len;
  uim_slot_eid_info eid_info[10];
};

struct uim_switch_slot_req {
  uint8_t logical_slot;
  uint32_t physical_slot;
};

struct uim_switch_slot_resp {
  uim_qmi_result result;
};

extern struct qmi_elem_info uim_open_logical_channel_req_ei[];
extern struct qmi_elem_info uim_open_logical_channel_resp_ei[];
extern struct qmi_elem_info uim_reset_req_ei[];
extern struct qmi_elem_info uim_reset_resp_ei[];
extern struct qmi_elem_info uim_send_apdu_req_ei[];
extern struct qmi_elem_info uim_send_apdu_resp_ei[];
extern struct qmi_elem_info uim_get_slots_req_ei[];
extern struct qmi_elem_info uim_get_slots_resp_ei[];
extern struct qmi_elem_info uim_switch_slot_req_ei[];
extern struct qmi_elem_info uim_switch_slot_resp_ei[];

#endif  // HERMES_UIM_CMD_H_
